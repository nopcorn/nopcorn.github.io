<!DOCTYPE html><html lang="en" ><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="Service Discovery in Kubernetes with Restrictive Permissions" /><meta name="author" content="nopcorn" /><meta property="og:locale" content="en_US" /><meta name="description" content="When operating in a kubernetes environment without permissions allowing you to list pods and services, there are other options for getting the lay of the land" /><meta property="og:description" content="When operating in a kubernetes environment without permissions allowing you to list pods and services, there are other options for getting the lay of the land" /><link rel="canonical" href="http://localhost:4000/2024/07/08/kubernetes-service-discovery" /><meta property="og:url" content="http://localhost:4000/2024/07/08/kubernetes-service-discovery" /><meta property="og:site_name" content="nopcorn" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-07-08T00:00:00-04:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Service Discovery in Kubernetes with Restrictive Permissions" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"nopcorn"},"dateModified":"2024-07-08T00:00:00-04:00","datePublished":"2024-07-08T00:00:00-04:00","description":"When operating in a kubernetes environment without permissions allowing you to list pods and services, there are other options for getting the lay of the land","headline":"Service Discovery in Kubernetes with Restrictive Permissions","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2024/07/08/kubernetes-service-discovery"},"url":"http://localhost:4000/2024/07/08/kubernetes-service-discovery"}</script><title> Service Discovery in Kubernetes with Restrictive Permissions - nopcorn</title><link rel="shortcut icon" href="/favicon.png"><link rel="alternate" type="application/atom+xml" title="nopcorn" href="/atom.xml"><link rel="alternate" type="application/json" title="nopcorn" href="http://localhost:4000/feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /><style> *,:after,:before{box-sizing:border-box;background-color:inherit;color:inherit;margin:0;padding:0}body{font-family:system-ui,sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;line-height:1.5;font-size:1rem;color:#16171a}hr{background:#dfdfdf !important;margin-top:1rem;margin-bottom:1rem}nav ul{border-right:1px solid #edf2f7}a{color:#000;text-decoration-skip-ink:auto;text-decoration:underline}pre{margin:.5rem 0;padding:.5rem}.post p{margin:.5rem 0}.post h1,.post h2,.post h3,.post h4{margin:1rem 0}.post h2:first-child,.project h2:first-child,.photo h2:first-child{margin-top:0}.meta{margin-bottom:1rem}code,pre{background:#ecedee}code{padding:.1rem;padding-left:.3rem;padding-right:.3rem}pre code{border:none}pre{padding:1rem;overflow-x:auto}img{max-width:100%}hr{background:#000;height:1px;border:0}header{flex-basis:10rem;flex-grow:1;position:relative}header a{text-decoration:none}header li{margin-bottom:.2rem;text-align:right;margin-right:2rem}header a.active{font-weight:bold}header,section{padding:1rem}blockquote{background-color:#eee;padding:1rem;margin-top:1rem;margin-bottom:1rem;border-left:5px solid #ddd}h1,h2,h3,h4,h5{line-height:1;margin:1rem 0;font-weight:600}section{margin-top:.45rem}section h1:first-child{margin-top:0}strong,b{font-weight:bold}.photos ul{list-style:none}.photos li{margin-bottom:1.5rem}.photo picture,.project picture{margin-bottom:.5rem}.posts ul,header ul{list-style:none}blockquote ul{margin-left:1rem}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.5rem}.posts li a,.posts li div,.projects li a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time,.projects li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}.post ul,.project ul,.post ol{list-style-position:inside}main{display:flex;flex-wrap:wrap;max-width:70rem;margin:2rem auto;padding:1rem}@media screen and (max-width: 45rem){header li{display:inline;margin-right:1rem}.logo{padding-bottom:1rem}header ul{border-bottom:1px solid #edf2f7;padding-bottom:2rem}nav ul{border-right:0px}.photos ul{margin-top:.5rem}#logo{width:5rem}}section{flex-basis:0;flex-grow:999;min-width:70%;display:flex;flex-direction:column}figcaption{font-size:smaller}@media print{.no-print,.no-print *{display:none !important}}code{font-size:.75rem;vertical-align:text-bottom}blockquote code{background:#fff}pre code{display:inline-block}pre{white-space:pre-wrap}#logo{border-radius:50% !important}pre:has(>.language-hack-nowrap){white-space:pre}#topnav{margin-top:1rem}.social-icons{width:2.5rem}blockquote ul,blockquote ol{list-style-position:unset !important}</style></head><body><main><header aria-hidden="true" class="no-print"> <a href="/"> <!--<h1 class="logo" style="margin-top:0;font-family:monospace">\x90corn</h1>--> <img id="logo" src="/assets/logo.jpeg"/> </a><nav id="topnav" role="navigation" aria-hidden="true"><ul><li><a href="/" >posts</a></li><li><a href="/about" >about</a></li><li><a href="/atom.xml" >rss</a></li></ul></nav></header><section class="post"><h2>Service Discovery in Kubernetes with Restrictive Permissions</h2><span class="meta"><time datetime="2024-07-08T00:00:00-04:00">July 8, 2024</time> &middot; <a href="/tag/kubernetes">kubernetes</a>, <a href="/tag/eks">eks</a>, <a href="/tag/k8s">k8s</a>, <a href="/tag/tradecraft">tradecraft</a>, <a href="/tag/discovery">discovery</a></span><blockquote><ul><li>Most Kubernetes clusters running CoreDNS support reverse DNS lookups by default</li><li>Listing pods and services in a cluster is considered a privileged action, protected by the <code>list</code> verb on the <code>services</code> and <code>namespace</code> resources</li><li>Bruteforcing the cluster’s IP space via reverse DNS lookups will reveal services available in the cluster</li><li>This allows for some light privilege escalation ™</li></ul></blockquote><p>In a recent red team engagement, I encountered a curious scenario while navigating a Kubernetes cluster. After exploiting a vulnerability in an ephemeral pod and deploying a customized version of the <a href="https://github.com/MythicAgents/poseidon">Poseidon</a> agent, I turned to lateral movement and privilege escalation. Generally, I start with the stored API creds already available in the pod located in <code>/var/run/secrets/kubernetes.io/serviceaccount/token</code> to see what I can access.</p><pre><code class="language-hack-nowrap">$ curl -L "https://dl.k8s.io/release/v1.30.2/bin/linux/amd64/kubectl" -o /tmp/kubectl
$ chmod +x /tmp/kubectl
$ /tmp/kubectl --token=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token) auth can-i --list
Resources                                       Non-Resource URLs                      Resource Names   Verbs
selfsubjectreviews.authentication.k8s.io        []                                     []               [create]
selfsubjectaccessreviews.authorization.k8s.io   []                                     []               [create]
selfsubjectrulesreviews.authorization.k8s.io    []                                     []               [create]
                                                [/.well-known/openid-configuration/]   []               [get]
                                                [/.well-known/openid-configuration]    []               [get]
                                                [/api/*]                               []               [get]
                                                [/api]                                 []               [get]
                                                [/apis/*]                              []               [get]
                                                [/apis]                                []               [get]
                                                [/healthz]                             []               [get]
                                                [/healthz]                             []               [get]
                                                [/livez]                               []               [get]
                                                [/livez]                               []               [get]
                                                [/openapi/*]                           []               [get]
                                                [/openapi]                             []               [get]
                                                [/openid/v1/jwks/]                     []               [get]
                                                [/openid/v1/jwks]                      []               [get]
                                                [/readyz]                              []               [get]
                                                [/readyz]                              []               [get]
                                                [/version/]                            []               [get]
                                                [/version/]                            []               [get]
                                                [/version]                             []               [get]
                                                [/version]                             []               [get]

</code></pre><p>In this case - I couldn’t access anything. This effectively rendered the Kubernetes API useless for further exploration unless I found a new token to try out. I turned to classic old-school lateral movement and host discovery.</p><p>I knew a SentinelOne agent was present on the hypervisor so fast network-based host discovery via <code>nmap</code> or <code>zmap</code> would be much too noisy and risk giving away the attacker advantage so early in the engagement. I thought about writing a quick and dirty python scanner with generous sleeping in between hosts, but after discovering I was in a <code>/16</code> I didn’t have the patience to sit through slowly working by way through 65000 potential live IPs. Additionally, I could identify a live IP but due to how Kubernetes clusters are managed that IP could be reassigned or abandoned at any time if a new deployment or load balancing was performed.</p><p>Instead I looked for quieter ways of identifying services and pods that wouldn’t be as scrutinized by security products and audit logs, but allowed me to progress somewhat quickly. I decided to take a look at how CoreDNS worked as there was likely less visibility on DNS queries and resolutions within a cluster.</p><p>In Kubernetes, DNS is used by pods to identify other services available in the cluster as IPs change frequently. Every service in Kubernetes is provisioned an entry in the cluster’s DNS that corresponds to its service name and the namespace that it’s in:</p><p><img src="/assets/img/k8s-dns-structure.png" alt="" /></p><p>The only namespace I knew of was the one I was currently in (found in <code>/run/secrets/kubernetes.io/serviceaccount/namespace</code>). I debated generating a wordlist of common namespace and service names but decided against bruteforcing.</p><p>From previously listing network interfaces, I knew that I was in a <code>/16</code> network and could iterate through the IP addresses performing <a href="https://en.wikipedia.org/wiki/Reverse_DNS_lookup">reverse lookups</a> if CoreDNS automatically inserted PRT records or if it resolved the <code>in-addr.arpa</code> domain name.</p><p>As it so happens, this is a <a href="https://kubernetes.io/docs/tasks/administer-cluster/dns-custom-nameservers/#coredns">feature of CoreDNS which is enabled by default</a>. The <code>in-addr.arpa</code> domain being present allows for the server to automatically resolve our reverse lookups.</p><p>I wrote a quick and dirty pastable python script that will read an IP range in CIDR notation from the environment and try a reverse resolution for each IP:</p><pre><code class="language-python">import socket
import ipaddress
import os

cidr = os.environ.get('cidr')
net = ipaddress.ip_network(cidr)
for ip in net:
    name = socket.getnameinfo((str(ip), 0), 0)[0]
    try:
        ipaddress.ip_address(name)
    except ValueError:
        print(f'{name} -&gt; {ip}') 
</code></pre><p>Collapsing this script into a one liner and running it through python looks something like this:</p><pre><code class="language-shell">$ cidr="172.20.0.0/16" python3 -c "exec(\"import socket\nimport ipaddress\nimport os\n\ncidr = os.environ.get('cidr')\nnet = ipaddress.ip_network(cidr)\n\nfor ip in net:\n\tname = socket.getnameinfo((str(ip), 0), 0)[0]\n\ttry:\n\t\tipaddress.ip_address(name)\n\texcept ValueError:\n\t\tprint(f'{name} -&gt; {ip}')\")" | grep -v "compute"
</code></pre><p>I had to grep out the non-service responses or else every IP address would return a default AWS resolution like <code>ip-172-20-0-7.us-east-1.compute.internal</code>.</p><p>Letting this script run for a bit gave me a complete list of services in the cluster and their currently associated IP addresses. Additionally, because the namespace a service is hosted in appears in the domain name for it, I get a partial list of valid namespaces in the cluster. <strong>This essentially allows an unprivileged token to give itself the <code>list</code> verb on the <code>services</code> and <code>namespaces</code> resources, even if they have been explicitly denied</strong>.</p><p>Armed with a list of valid services in the network I could now pivot to software identification and port scanning.</p></section></main><script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "8156489757ba4337bde96df7a40dcc1b"}'></script></body></html>
